# Models of Computation
This week in class we discussed using rewriting as a model of computation.  Understanding the importance of rewriting in computation is fundamental in understanding how our devices read symbols and rewriting them into new ones.  The way we rewrite input and generate output in computation is dependent on a set of equations, called rewrite rules.  Just like other techniques we have learned in most of our school mathematics courses- rewriting terms normally reduces the complexity of an expression, therefore can be synonymous to simplification, or reduction.  However, depending on the rewrite rule we apply, it could also make the expression more complex and complicated even though it is semantically equivalent to its original, simpler form.  

In class, we visualized each term as a tree of symbols and operations.  The tree defines the set of rules, principles, and processes that govern the structure of the syntax of a programming language.  Each set of symbols is defined by a given signature (syntactic symbols the machine can understand). We expressed each set in a notation technique called the Backusâ€“Naur form or Backus normal form (BNF) for context-free grammars.  For example,  a simple model of computation or expression containing addition and multiplication rules can be represented as:
![Alt Text](https://github.com/Namsinh/CPSC354-blog/blob/master/syntaxTree.png)

We can think of these parse trees as a term of a program object that allows us to visualize the structure of our computation from the bottom up.  The nodes and branches of the tree express the operational structures and rewrite rules of the programming language, the leaves are the values we begin with at the start of the program, and the root is the result.  Programs in tree form can be transformed or optimized by applying rewriting rules. 
