# Models of Computation
This week in class we discussed using rewriting as a model of computation.  Understanding the importance of rewriting in computation is fundamental in understanding how our devices read symbols and rewriting them into new ones.  The way we rewrite input and generate output in computation is dependent on a set of equations, called rewrite rules.  Just like other techniques we have learned in most of our school mathematics courses- rewriting terms normally reduces the complexity of an expression, therefore can be synonymous to simplification, or reduction.  However, depending on the rewrite rule we apply, it could also make the expression more complex and complicated even though it is semantically equivalent to its original, simpler form.  

In class, we visualized each term as a tree of symbols and operations.  The tree defines the set of rules, principles, and processes that govern the structure of the syntax of a programming language.  Each set of symbols is defined by a given signature (syntactic symbols the machine can understand). We expressed each set in a notation technique called the Backusâ€“Naur form or Backus normal form (BNF) for context-free grammars.  For example,  a simple model of computation of addition and multiplication can be represented as:
![Syntax Tree](/CPSC354-blog/syntaxTree.png)

We can think of these syntax trees as a term of a program object.  And the nodes and branches express the operational structures and rewrite rules of the programming language.  Programs in tree form can be transformed or optimized by applying rewriting rules. 
